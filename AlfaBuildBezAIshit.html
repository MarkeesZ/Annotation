<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>YOLOv8 Segmentation Tool (Editable with .txt Annotations)</title>
  <style>
    canvas {
      border: 1px solid black;
      cursor: crosshair;
    }
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      z-index: 100;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
</head>
<body>
  <div id="toolbar">
    <label>Class:
      <select id="classSelect">
        <option value="0">Car</option>
        <option value="1">Free Parking Space</option>
      </select>
    </label>
    <label>Tool:
      <select id="toolSelect">
        <option value="draw">Draw</option>
        <option value="pan">Pan</option>
        <option value="select">Select</option>
        <option value="move">Move</option>
      </select>
    </label>
    <button onclick="undoPoint()">Undo Point</button>
    <button onclick="undoPolygon()">Undo Polygon</button>
    <button onclick="completePolygon()">Complete Polygon</button>
    <button onclick="prevImage()">Iepriekšējais</button>
    <button onclick="nextImage()">Nākamais</button>
    <button onclick="exportAnnotations()">Export TXT</button>
    <!-- Atbalsta arī .txt failu augšupielādi kopā ar attēliem -->
    <input accept="image/*,.txt" id="imageLoader" multiple name="imageLoader" type="file"/>
    <button onclick="deleteSelectedPolygon()">Delete Selected Polygon</button>
    <button onclick="switchSelectedPolygonClass()">Switch Class</button>
    <button onclick="undoAction()">Undo Action</button>
    <button onclick="redoAction()">Redo Action</button>
    <div id="counters" style="margin-top:10px;">
      <strong>Car Count:</strong> <span id="carCount">0</span> |
      <strong>Free Space Count:</strong> <span id="freeCount">0</span>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <div id="thumbnailBar" style="position:fixed; bottom:0; left:0; right:0; background:#f0f0f0; overflow-x:auto; white-space:nowrap; padding:5px; border-top:1px solid #ccc; z-index:101;"></div>
  
  <script>
    // Globālie mainīgie
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageLoader = document.getElementById('imageLoader');
    let currentClass = 0;
    let tool = 'draw';
    // "images" masīvā saglabājam objektus ar šādām īpašībām: baseName, image (File) un annotation (File, ja pieejams)
    let images = [];
    let imageIndex = 0;
    let image = new Image();
    // polygons objekts saglabā polygonu datus atslēgā pēc attēla baseName
    let polygons = {};
    let currentPolygon = [];
    let isPanning = false;
    let startX, startY;
    let offsetX = 0, offsetY = 0;
    let zoom = 1;
    let selectedPolygonIndex = null;
    // currentImageName – pašreizējā attēla bāzes nosaukums (bez paplašinājuma)
    let currentImageName = '';

    // History steki undo/redo
    let historyStack = [];
    let redoStack = [];
    
    function saveHistory() {
      const clone = JSON.parse(JSON.stringify(polygons));
      historyStack.push(clone);
      redoStack = [];
    }
    
    // Palīgsfunkcija: pārbauda, vai dots punkts atrodas iekšā polygonā
    function pointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > y) !== (yj > y)) &&
                          (x < (xj - xi) * (y - yi) / (yj - yi + 0.0000001) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    
    // Atjaunina live counters (Car/Free Space skaits)
    function updateCounters() {
      let cars = 0;
      let free = 0;
      if (currentImageName && polygons[currentImageName]) {
        for (const poly of polygons[currentImageName]) {
          if (poly.class === 0) cars++;
          else if (poly.class === 1) free++;
        }
      }
      document.getElementById('carCount').textContent = cars;
      document.getElementById('freeCount').textContent = free;
    }
    
    // Zīmē attēlu un visus polygonus
    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(zoom, 0, 0, zoom, offsetX, offsetY);
      ctx.drawImage(image, 0, 0);
      
      if (!polygons[currentImageName]) polygons[currentImageName] = [];
      
      polygons[currentImageName].forEach((poly, idx) => {
        ctx.beginPath();
        ctx.moveTo(poly.points[0].x, poly.points[0].y);
        for (let i = 1; i < poly.points.length; i++) {
          ctx.lineTo(poly.points[i].x, poly.points[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = (poly.class === 0 ? 'rgba(0,0,255,0.4)' : 'rgba(0,255,0,0.4)');
        ctx.fill();
        ctx.strokeStyle = (idx === selectedPolygonIndex ? 'yellow' : 'black');
        ctx.lineWidth = 2;
        ctx.stroke();
      });
      
      // Zīmē pašreizējo (vēl nepabeigto) polygonu
      if (currentPolygon.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentPolygon[0].x, currentPolygon[0].y);
        for (let i = 1; i < currentPolygon.length; i++) {
          ctx.lineTo(currentPolygon[i].x, currentPolygon[i].y);
        }
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
    
    // Nolasām anotāciju faila saturu un pārvēršam to polygonu masīvā
    function loadAnnotations(annotationFile, callback) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const content = e.target.result;
        const lines = content.split("\n");
        let loadedPolygons = [];
        for (let line of lines) {
          line = line.trim();
          if (!line) continue;
          const tokens = line.split(/\s+/);
          const cls = parseInt(tokens[0]);
          let points = [];
          // Pārvēršam relatīvās koordinātas uz pikseļiem (izmantojot canvas izmērus)
          for (let i = 1; i < tokens.length; i += 2) {
            const relX = parseFloat(tokens[i]);
            const relY = parseFloat(tokens[i+1]);
            points.push({ x: relX * canvas.width, y: relY * canvas.height });
          }
          loadedPolygons.push({ points: points, class: cls });
        }
        callback(loadedPolygons);
      };
      reader.readAsText(annotationFile);
    }
    
    // Ielādē attēlu (un, ja pieejams, arī anotāciju) pēc indexa
    function loadImage(index) {
      const data = images[index];
      const reader = new FileReader();
      reader.onload = function(e) {
        currentImageName = data.baseName;
        image.onload = () => {
          selectedPolygonIndex = null;
          canvas.width = image.width;
          canvas.height = image.height;
          draw();
          // Ja pieejams anotāciju fails, nolasam to
          if (data.annotation) {
            loadAnnotations(data.annotation, function(loadedPolys) {
              polygons[currentImageName] = loadedPolys;
              draw();
              updateCounters();
            });
          } else {
            polygons[currentImageName] = polygons[currentImageName] || [];
            updateCounters();
          }
        };
        image.src = e.target.result;
      };
      reader.readAsDataURL(data.image);
    }
    
    // Apstrāde, kad lietotājs augšupielādē failus (attēli un/vai .txt anotācijas)
    imageLoader.addEventListener('change', function(e) {
      const newFiles = Array.from(e.target.files);
      if (newFiles.length === 0) return;
      
      // Izveidojam pagaidu objektu, kur faili tiek sasaistīti pēc bāzes nosaukuma
      let dataMap = {};
      newFiles.forEach(file => {
        const fileName = file.name;
        const lowerName = fileName.toLowerCase();
        // Izgūstam bāzes nosaukumu (bez paplašinājuma)
        const baseName = fileName.replace(/\.[^/.]+$/, "");
        if (!dataMap[baseName]) {
          // Inicializējam objektu ar baseName, kur ieliek attēla un anotāciju failu
          dataMap[baseName] = { baseName: baseName, image: null, annotation: null };
        }
        if (lowerName.endsWith('.txt')) {
          dataMap[baseName].annotation = file;
        } else if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg') ||
                   lowerName.endsWith('.png') || lowerName.endsWith('.gif')) {
          dataMap[baseName].image = file;
        }
      });
      
      // Saglabājam tikai objektus, kuriem ir noteikts attēla fails
      Object.values(dataMap).forEach(item => {
        if (item.image) {
          images.push(item);
        }
      });
      
      // Ja pašreizējais attēls nav iestatīts, ielādējam pirmo no saraksta
      if (!currentImageName && images.length > 0) {
        imageIndex = 0;
        loadImage(imageIndex);
      }
      e.target.value = "";
    });
    
    document.getElementById('classSelect').addEventListener('change', (e) => {
      currentClass = parseInt(e.target.value);
    });
    
    document.getElementById('toolSelect').addEventListener('change', (e) => {
      tool = e.target.value;
    });
    
    // Notikumu apstrāde uz canvas
    canvas.addEventListener('mousedown', function(e) {
      const x = (e.offsetX - offsetX) / zoom;
      const y = (e.offsetY - offsetY) / zoom;
      
      if (tool === 'pan') {
        isPanning = true;
        startX = e.clientX - offsetX;
        startY = e.clientY - offsetY;
      } else if (tool === 'draw') {
        currentPolygon.push({ x, y });
        draw();
      } else if (tool === 'select') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const relX = (mouseX - offsetX) / zoom;
        const relY = (mouseY - offsetY) / zoom;
        const polys = polygons[currentImageName] || [];
        selectedPolygonIndex = null;
        for (let i = 0; i < polys.length; i++) {
          if (pointInPolygon(relX, relY, polys[i].points)) {
            selectedPolygonIndex = i;
            break;
          }
        }
        draw();
      } else if (tool === 'move') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offsetX) / zoom;
        const mouseY = (e.clientY - rect.top - offsetY) / zoom;
        const polys = polygons[currentImageName] || [];
        selectedPolygonIndex = null;
        for (let i = 0; i < polys.length; i++) {
          if (pointInPolygon(mouseX, mouseY, polys[i].points)) {
            selectedPolygonIndex = i;
            isDraggingPolygon = true;
            dragOffset = { x: mouseX, y: mouseY };
            break;
          }
        }
      }
    });
    
    canvas.addEventListener('mouseup', function(e) {
      isPanning = false;
      if (draggingPoint !== null) {
        saveHistory();
        draggingPoint = null;
        canvas.style.cursor = 'default';
      }
      if (tool === 'move' && isDraggingPolygon) {
        saveHistory();
        isDraggingPolygon = false;
      }
    });
    
    canvas.addEventListener('mousemove', function(e) {
      if (tool === 'pan' && isPanning) {
        offsetX = e.clientX - startX;
        offsetY = e.clientY - startY;
        draw();
      }
      if (tool === 'move' && isDraggingPolygon && selectedPolygonIndex !== null) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offsetX) / zoom;
        const mouseY = (e.clientY - rect.top - offsetY) / zoom;
        const dx = mouseX - dragOffset.x;
        const dy = mouseY - dragOffset.y;
        let polygon = polygons[currentImageName][selectedPolygonIndex];
        polygon.points = polygon.points.map(p => ({ x: p.x + dx, y: p.y + dy }));
        dragOffset = { x: mouseX, y: mouseY };
        draw();
      }
    });
    
    canvas.addEventListener('wheel', function(e) {
      if (e.ctrlKey) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const x = (mouseX - offsetX) / zoom;
        const y = (mouseY - offsetY) / zoom;
        const delta = -e.deltaY / 1000;
        const newZoom = Math.min(Math.max(zoom + delta, 0.1), 10);
        offsetX -= (x * newZoom - x * zoom);
        offsetY -= (y * newZoom - y * zoom);
        zoom = newZoom;
        draw();
      }
    });
    
    // Main variables, lai pārvietotu individuālus punktus
    let draggingPoint = null;
    let isDraggingPolygon = false;
    let dragOffset = { x: 0, y: 0 };
    
    canvas.addEventListener('mousedown', function(e) {
      if (tool === 'select' && selectedPolygonIndex !== null) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offsetX) / zoom;
        const mouseY = (e.clientY - rect.top - offsetY) / zoom;
        const polygon = polygons[currentImageName][selectedPolygonIndex].points;
        for (let i = 0; i < polygon.length; i++) {
          const pt = polygon[i];
          const dx = pt.x - mouseX;
          const dy = pt.y - mouseY;
          if (Math.sqrt(dx * dx + dy * dy) < 10 / zoom) {
            draggingPoint = i;
            canvas.style.cursor = 'grabbing';
            break;
          }
        }
      }
    });
    
    canvas.addEventListener('mousemove', function(e) {
      if (draggingPoint !== null && selectedPolygonIndex !== null && tool === 'select') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - offsetX) / zoom;
        const mouseY = (e.clientY - rect.top - offsetY) / zoom;
        polygons[currentImageName][selectedPolygonIndex].points[draggingPoint] = { x: mouseX, y: mouseY };
        draw();
      }
    });
    
    canvas.addEventListener('mouseup', function(e) {
      if (draggingPoint !== null && tool === 'select') {
        saveHistory();
        draggingPoint = null;
        canvas.style.cursor = 'default';
        updateCounters();
      }
    });
    
    // Anotāciju manipulēšanas funkcijas
    
    function completePolygon() {
      if (!polygons[currentImageName]) polygons[currentImageName] = [];
      currentPolygon.class = currentClass;
      saveHistory();
      polygons[currentImageName].push({ points: [...currentPolygon], class: currentClass });
      currentPolygon = [];
      draw();
      updateCounters();
    }
    
    function undoPoint() {
      currentPolygon.pop();
      draw();
    }
    
    function undoPolygon() {
      if (polygons[currentImageName]) {
        saveHistory();
        polygons[currentImageName].pop();
        draw();
        updateCounters();
      }
    }
    
    function undoAction() {
      if (historyStack.length > 0) {
        redoStack.push(JSON.parse(JSON.stringify(polygons)));
        polygons = historyStack.pop();
        draw();
        updateCounters();
      }
    }
    
    function redoAction() {
      if (redoStack.length > 0) {
        historyStack.push(JSON.parse(JSON.stringify(polygons)));
        polygons = redoStack.pop();
        draw();
        updateCounters();
      }
    }
    
    function switchSelectedPolygonClass() {
      if (selectedPolygonIndex !== null && polygons[currentImageName]) {
        saveHistory();
        const polygon = polygons[currentImageName][selectedPolygonIndex];
        polygon.class = (polygon.class === 0 ? 1 : 0);
        draw();
        updateCounters();
      }
    }
    
    function deleteSelectedPolygon() {
      if (selectedPolygonIndex !== null && polygons[currentImageName]) {
        saveHistory();
        polygons[currentImageName].splice(selectedPolygonIndex, 1);
        selectedPolygonIndex = null;
        draw();
        updateCounters();
      }
    }
    
    function prevImage() {
      if (imageIndex > 0) {
        imageIndex--;
        loadImage(imageIndex);
      }
    }
    
    function nextImage() {
      if (imageIndex < images.length - 1) {
        imageIndex++;
        loadImage(imageIndex);
      }
    }
    
    function exportAnnotations() {
      const zip = new JSZip();
      for (const [fileName, anns] of Object.entries(polygons)) {
        const lines = anns.map(p => {
          const cls = p.class;
          const coords = p.points.map(pt => `${(pt.x / canvas.width).toFixed(6)} ${(pt.y / canvas.height).toFixed(6)}`).join(' ');
          return `${cls} ${coords}`;
        }).join('\n');
        zip.file(fileName.replace(/\.[^/.]+$/, ".txt"), lines);
      }
      zip.generateAsync({ type: "blob" }).then(content => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = "annotations.zip";
        a.click();
      });
    }
  </script>
</body>
</html>
